package de.codecentric.reedelk.plugin.action.openapi.template;

import com.intellij.openapi.editor.Document;
import com.intellij.openapi.fileEditor.FileDocumentManager;
import com.intellij.openapi.vfs.VirtualFile;
import de.codecentric.reedelk.plugin.template.WritingStrategyOverride;
import org.json.JSONArray;
import org.json.JSONObject;

import java.io.IOException;
import java.util.Optional;

import static de.codecentric.reedelk.runtime.commons.JsonParser.Flow;

public class WritingStrategyOpenApi extends WritingStrategyOverride {

    @Override
    public Optional<VirtualFile> write(String templateText, VirtualFile destinationDir, String fileName) throws IOException {
        VirtualFile existingFlowFile = destinationDir.findChild(fileName);
        if (existingFlowFile == null) {
            // File does not exists, we use the default strategy override or create new file.
            return super.write(templateText, destinationDir, fileName);
        }

        // A file with file name exists already. It has to be overridden.
        // We have two cases:
        // 1. It is a Flow file -> we must update only the first component (RESTListener) with the
        //  one generated by the template + flow title and description coming from OpenApi.
        // 2. It is NOT a Flow file -> we must override the file completely.
        Document existingFlowDocument = FileDocumentManager.getInstance().getDocument(existingFlowFile);

        try {
            // We try to parse the existing flow file.
            JSONObject existingFlowJsonObject = new JSONObject(existingFlowDocument.getText());

            // Copy over properties from the existing to the generated
            JSONObject generatedFlowJsonObject = new JSONObject(templateText);
            updateExistingFlowDefinition(existingFlowJsonObject, generatedFlowJsonObject);

            // Write back in the document the existing flow
            String serializedUpdatedFlow = existingFlowJsonObject.toString(2);
            existingFlowDocument.setText(serializedUpdatedFlow);

            return Optional.of(existingFlowFile);

        } catch (Exception e) {
            return super.write(templateText, destinationDir, fileName);
        }
    }

    /**
     * Updates into the existing flow definition the properties value from the generated flow.
     */
    public void updateExistingFlowDefinition(JSONObject existing, JSONObject generated) {
        String generatedTitle = Flow.title(generated);
        Flow.title(generatedTitle, existing);

        String generatedDescription = Flow.description(generated);
        Flow.description(generatedDescription, existing);

        // Replace first component in the flow: RESTListener.
        JSONArray generatedFlowsDefinitions = generated.getJSONArray(Flow.flow());
        JSONObject generatedRestListenerConfig = generatedFlowsDefinitions.getJSONObject(0);
        JSONArray existingFlowsComponents = Flow.flow(existing);
        existingFlowsComponents.put(0, generatedRestListenerConfig);
    }
}
