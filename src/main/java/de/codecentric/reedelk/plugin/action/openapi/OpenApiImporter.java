package de.codecentric.reedelk.plugin.action.openapi;

import de.codecentric.reedelk.openapi.OpenApi;
import de.codecentric.reedelk.openapi.v3.model.OpenApiObject;
import de.codecentric.reedelk.openapi.v3.model.PathsObject;
import de.codecentric.reedelk.openapi.v3.model.ServerObject;
import de.codecentric.reedelk.plugin.action.openapi.handler.Handlers;
import de.codecentric.reedelk.plugin.action.openapi.reader.FileReader;
import de.codecentric.reedelk.plugin.action.openapi.reader.Readers;
import de.codecentric.reedelk.plugin.action.openapi.serializer.ConfigurationOpenApiObject;
import de.codecentric.reedelk.plugin.action.openapi.serializer.Serializer;
import de.codecentric.reedelk.plugin.action.openapi.template.OpenApiRESTListenerConfigProperties;
import de.codecentric.reedelk.plugin.commons.DefaultConstants;
import de.codecentric.reedelk.runtime.api.commons.StringUtils;
import org.jetbrains.annotations.NotNull;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.Arrays;
import java.util.List;

import static de.codecentric.reedelk.plugin.message.ReedelkBundle.message;
import static de.codecentric.reedelk.runtime.api.commons.StringUtils.isNotBlank;


public class OpenApiImporter {

    private final OpenApiImporterContext context;
    private int apiPort;
    private String host = DefaultConstants.OpenApi.LOCALHOST;
    private String apiBasePath;
    private String apiTitle = message("openapi.importer.config.default.file.title");

    public OpenApiImporter(@NotNull OpenApiImporterContext context) {
        this.context = context;
    }

    public void openApiImport() throws OpenApiException {

        // Read the OpenAPI definition as string
        String content = createOpenApiReader().read();
        context.setSchemaFormat(content);

        // Deserialize the content into the OpenAPI Model
        OpenApiObject openApiObject = OpenApi.from(content);

        // Discover open api properties
        apiTitle = OpenApiUtils.getApiTitle(openApiObject);
        apiBasePath = getBasePath(openApiObject);
        apiPort = findListenerPort(openApiObject);

        // We must remove the localhost server URL object, because
        // it will be automatically generated by the Reedelk Runtime
        // when the openapi.json or openapi.yaml is being published.
        extractLocalhostServerIfDefined(openApiObject.getServers());

        // Generate REST Listener configuration
        ConfigurationOpenApiObject configurationOpenApiObject = new ConfigurationOpenApiObject(
                openApiObject.getInfo(),
                openApiObject.getServers(),
                openApiObject.getComponents());
        String configOpenApiObjectJson = Serializer.toJson(configurationOpenApiObject, context);
        String title = OpenApiUtils.restListenerConfigTitleFrom(openApiObject);
        String configFileName = OpenApiUtils.restListenerConfigFileNameFrom(openApiObject);

        OpenApiRESTListenerConfigProperties properties = new OpenApiRESTListenerConfigProperties();
        properties.setOpenApiObject(configOpenApiObjectJson);
        properties.setId(context.getRestListenerConfigId());
        properties.setBasePath(apiBasePath);
        properties.setPort(apiPort);
        properties.setTitle(title);
        properties.setHost(host);
        context.createRestListenerConfig(configFileName, properties);

        // Generate REST flows from paths
        PathsObject paths = openApiObject.getPaths();
        paths.getPaths().forEach((pathEntry, pathItem) -> Handlers.handle(context, pathEntry, pathItem));
    }

    public String getHost() {
        return host;
    }

    public int getApiPort() {
        return apiPort;
    }

    public String getApiTitle() {
        return apiTitle;
    }

    public String getApiBasePath() {
        return apiBasePath;
    }

    private FileReader createOpenApiReader() {
        return isNotBlank(context.getOpenApiFilePath()) ?
                new Readers.FileSystemFileReader(context.getOpenApiFilePath()) :
                new Readers.RemoteFileReader(context.getApiFileUrl());
    }

    int findListenerPort(OpenApiObject openApiObject) {
        if (context.getOpenApiPort() != null) {
            return context.getOpenApiPort();
        }
        return openApiObject.getServers().stream()
                .filter(this::isLocalhost)
                .map(this::getPortOrDefault)
                .findFirst()
                .orElse(DefaultConstants.OpenApi.HTTP_PORT);
    }

    String getBasePath(OpenApiObject openApiObject) {
        if (isNotBlank(context.getBasePath())) {
            return context.getBasePath();
        }
        return openApiObject.getServers()
                .stream()
                .findFirst()
                .map(this::extractBasePath)
                .orElse(DefaultConstants.OpenApi.BASE_PATH);
    }

    private int getPortOrDefault(ServerObject serverObject) {
        String serverUrl = appendProtocolIfNotExists(serverObject);
        try {
            URL url = new URL(serverUrl);
            return url.getPort() > 0 ? url.getPort() : DefaultConstants.OpenApi.HTTP_PORT;
        } catch (MalformedURLException exception) {
            return DefaultConstants.OpenApi.HTTP_PORT;
        }
    }

    private boolean isLocalhost(ServerObject serverObject) {
        String serverUrl = appendProtocolIfNotExists(serverObject);
        try {
            URL url = new URL(serverUrl);
            String urlHost = url.getHost();
            return DefaultConstants.OpenApi.LOCALHOST.equals(urlHost) ||
                    DefaultConstants.OpenApi.ANY_ADDRESS.equals(urlHost);
        } catch (MalformedURLException e) {
            return false;
        }
    }

    private String extractBasePath(ServerObject serverObject) {
        String serverUrl = appendProtocolIfNotExists(serverObject);
        try {
            URL url = new URL(serverUrl);
            String path = url.getPath();
            String[] pathSegments = path.split("/");
            if (pathSegments.length > 1) {
                // If there are more segments, http://myhost.com/api/v35 we expect: /api/v35.
                String[] subSegments = Arrays.copyOfRange(pathSegments, 1, pathSegments.length);
                return "/" + String.join("/", subSegments);
            } else {
                return StringUtils.EMPTY; // no base path present. The base path is '/openapi.json'.
            }
        } catch (MalformedURLException e) {
            return DefaultConstants.OpenApi.BASE_PATH;
        }
    }

    /**
     * We just add the protocol in order to let the java.net object to correctly parse it.
     * Possible cases are:
     * - localhost:8282
     * - localhost
     * - http://localhost:8282
     * - http://localhost
     * - {scheme}://developer.uspto.gov/ds-api
     */
    @NotNull
    private String appendProtocolIfNotExists(ServerObject serverObject) {
        String serverUrl = serverObject.getUrl();
        if (serverUrl.indexOf("://") > 0) {
            // We remove the {scheme}:// part if it starts with a variable.
            // (e.g {scheme}://developer.uspto.gov/ds-api)
            serverUrl = serverUrl.substring(serverUrl.indexOf("://") + 3);
        }
        if (!(serverUrl.startsWith(PROTOCOL_HTTP) || serverUrl.startsWith(PROTOCOL_HTTPS))) {
            serverUrl = PROTOCOL_HTTP + serverUrl;
        }
        return serverUrl;
    }

    // We must remove it
    private void extractLocalhostServerIfDefined(List<ServerObject> servers) {
        servers.removeIf(this::isLocalhost);
    }

    private static final String PROTOCOL_HTTP = "http://";
    private static final String PROTOCOL_HTTPS = "https://";
}
